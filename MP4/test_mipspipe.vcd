$date
	Mon Apr 23 22:39:10 2018
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module test_mipspipe $end
$var reg 1 ! clock $end
$var reg 4 " clock_cycle [3:0] $end
$scope module u_mipspipe_mp4 $end
$var wire 1 # bypassAfromALUinWB $end
$var wire 1 $ bypassAfromLWinWB $end
$var wire 1 % bypassAfromMEM $end
$var wire 1 & bypassBfromALUinWB $end
$var wire 1 ' bypassBfromLWinWB $end
$var wire 1 ( bypassBfromMEM $end
$var wire 1 ! clock $end
$var wire 1 ) stall $end
$var wire 1 * takebranch $end
$var wire 5 + MEMWBrt [4:0] $end
$var wire 5 , MEMWBrd [4:0] $end
$var wire 6 - MEMWBop [5:0] $end
$var wire 5 . IDEXrt [4:0] $end
$var wire 5 / IDEXrs [4:0] $end
$var wire 6 0 IDEXop [5:0] $end
$var wire 5 1 EXMEMrd [4:0] $end
$var wire 6 2 EXMEMop [5:0] $end
$var wire 32 3 Bin [31:0] $end
$var wire 32 4 Ain [31:0] $end
$var reg 32 5 EXMEMALUOut [31:0] $end
$var reg 32 6 EXMEMB [31:0] $end
$var reg 32 7 EXMEMIR [31:0] $end
$var reg 32 8 IDEXA [31:0] $end
$var reg 32 9 IDEXB [31:0] $end
$var reg 32 : IDEXIR [31:0] $end
$var reg 32 ; IFIDIR [31:0] $end
$var reg 32 < MEMWBIR [31:0] $end
$var reg 32 = MEMWBValue [31:0] $end
$var reg 32 > PC [31:0] $end
$var reg 6 ? i [5:0] $end
$var reg 11 @ j [10:0] $end
$var reg 11 A k [10:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b10000000000 A
b10000000000 @
b100000 ?
b0 >
bx =
b100000 <
b100000 ;
b100000 :
bx 9
bx 8
b100000 7
bx 6
bx 5
bx 4
bx 3
b0 2
b0 1
b0 0
b0 /
b0 .
b0 -
b0 ,
b0 +
0*
0)
0(
0'
0&
0%
0$
0#
b0 "
0!
$end
#5
b0 3
b0 4
b0 9
b0 8
b100 >
b10001100101000110000000000000010 ;
b1 "
1!
#10
0!
#15
b11 3
b101 4
b101 /
b11 .
b100011 0
b0 6
b0 5
b10001100101000110000000000000010 :
b11 9
b101 8
b1000 >
b10001100011000100000000000000111 ;
b10 "
1!
#20
0!
#25
b10 3
b11 4
b100011 2
b11 /
b10 .
b0 =
b11 6
b10001100101000110000000000000010 7
b111 5
b10001100011000100000000000000111 :
b10 9
b11 8
b1100 >
b10000001000000000000000000011 ;
b11 "
1!
#30
0!
#35
b0 3
b1 4
b11 +
b100011 -
b1 /
b0 .
b100 0
b10001100101000110000000000000010 <
b1101 =
b10 6
b10001100011000100000000000000111 7
b1010 5
b10000001000000000000000000011 :
b0 9
b1 8
b10000 >
b10001100000010110000000000010000 ;
b100 "
1!
#40
0!
#45
b1011 3
b0 4
b10 +
b100 2
b0 /
b1011 .
b100011 0
b10001100011000100000000000000111 <
b0 =
b0 6
b10000001000000000000000000011 7
b10001100000010110000000000010000 :
b1011 9
b0 8
b10100 >
b10101101011011110000000000001001 ;
b101 "
1!
#50
0!
#55
b1111 3
b1011 4
1*
b0 +
b100 -
b100011 2
b1011 /
b1111 .
b101011 0
b10000001000000000000000000011 <
b1011 6
b10001100000010110000000000010000 7
b10000 5
b10101101011011110000000000001001 :
b1111 9
b1011 8
b11000 >
b10000001000010000000000000001 ;
b110 "
1!
#60
0!
#65
b1 3
b1 4
0*
b1011 +
b100011 -
b101011 2
b1 /
b1 .
b100 0
b10001100000010110000000000010000 <
b11 =
b1111 6
b10101101011011110000000000001001 7
b10100 5
b10000001000010000000000000001 :
b1 9
b1 8
b11100 >
b100000 ;
b111 "
1!
#70
0!
#75
b0 3
b0 4
b1111 +
b101011 -
b100 2
b0 /
b0 .
b0 0
b10101101011011110000000000001001 <
b1 6
b10000001000010000000000000001 7
b100000 :
b0 9
b0 8
b100000 >
b10001100000010110000000000010000 ;
b1000 "
1!
#80
0!
#85
b11 3
b1 +
b100 -
b0 2
b1011 .
b100011 0
b10000001000010000000000000001 <
b0 6
b100000 7
b0 5
b10001100000010110000000000010000 :
b11 9
b100100 >
b1010110110000000100000 ;
b1001 "
1!
#90
0!
#95
b1 4
b0 +
b0 -
b100011 2
b1 /
b0 0
b100000 <
b0 =
b11 6
b10001100000010110000000000010000 7
b10000 5
b1010110110000000100000 :
b1 8
b101000 >
b100000 ;
b1010 "
1!
#100
0!
#105
b0 3
b0 4
b1011 +
b100011 -
b1100 1
b0 2
b0 /
b0 .
b10001100000010110000000000010000 <
b11 =
b1010110110000000100000 7
b100 5
b100000 :
b0 9
b0 8
b101100 >
b1011 "
1!
#110
0!
#115
b1100 ,
b0 -
b0 1
b1010110110000000100000 <
b100 =
b0 6
b100000 7
b0 5
b110000 >
b1100 "
1!
#120
0!
#125
b0 ,
b0 +
b100000 <
b0 =
b110100 >
b1101 "
1!
#130
0!
#135
b111000 >
b1110 "
1!
#140
0!
#145
b111100 >
b1111 "
1!
#150
0!
#155
b1000000 >
b0 "
1!
#160
0!
